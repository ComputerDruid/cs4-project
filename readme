Dan Johnson + Joe Hallahan

Commit Log:
https://github.com/ComputerDruid/cs4-project/commits/master

Rationale:
----------
The common solver is implemented in the solver.cpp file. It takes a configuration,
and knows to call the forward-declared is_goal and find_neighbors methods. The idea
is that it does not have to work with the configurations directly, only calling
helper methods provided by the puzzle-specific objects, here implemented in
clock.cpp. The solver uses a simple Breadth-First-Search to find the nearest goal.
Additionally, the each configuration hlds a pointer to the previous configuration,
which allows for efficient backtracking once the goal configuration is found to
determine the path taken. Unfortunately, this approach requires reference-counting
to not leak memory, which is done manually here, although valgrind confirms
that it does not leak memory.

Command Line Usage:
-------------------

usage: clock hours start end
usage: water goal_value bucket1 ...

Sample Run:
-----------

$ clock 24 12 1
Step 1: 12
Step 2: 11
Step 3: 10
Step 4: 9
Step 5: 8
Step 6: 7
Step 7: 6
Step 8: 5
Step 9: 4
Step 10: 3
Step 11: 2
Step 12: 1

$ water 5 3 4
Step 1: [0 0]
Step 2: [4 0]
Step 3: [0 4]
Step 4: [4 4]
Step 5: [3 5]

How to make a new puzzle:
-------------------------

Inherit from the Configuration class, being sure to be able to store your own state
and display it when prompted via display()

include the following header files:
#include "Configuration.h"
#include "solver.h"

implement the following 2 helper functions (where PuzzleConf is your subclass of Configuration):

///Returns true if the given configuration is a solution
bool is_goal(const PuzzleConf& c);

///return a list of neighbor configurations to the given configuration
list<PuzzleConf> find_neighbors(PuzzleConf* current);

call the following method with the initial configuration.
PuzzleConf solve<PuzzleConf>(PuzzleConf start);

optionally call the following method to print the found solution:
void print_solution(Configuration* c);

link with solver.o (the solver methods) and Configuration.o (the configuration class)

Design
======

Configuration:
--------------
* state information (in subclass)
* pointer to previous configuration (NULL if initial condition)
* configurations are equal if states are equal (regardless of previous
  configuation)

Solver methods:
---------------
* is_goal(Configuration subclass): returns if the specified configuration meets the
  goal condition
* find_neighbors(Configuration subclass): returns a list of configurations next to the
  given configuration
* print_solution(Configuration): print the path taken to reach the specified
  configuration
* solve(initial configuration): returns the nearest goal configuration
  reachable from the given initial configuration. Is a templated function to be
  able to properly handle callbacks for varios types of configurations.

Main (flow of control):
-----------------------
create initial configuration
solve() for solution:
	BFS using is_goal() for end condition, and find_neighbors()
print_solution()
